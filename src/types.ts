import { z } from "zod";

/**
 * Domain classification for routing queries to appropriate handlers
 */
export const DomainSchema = z.enum([
  "commit",
  "interaction", 
  "conversation",
  "file",
  "project",
  "user",
  "other"
]);

export type Domain = z.infer<typeof DomainSchema>;

/**
 * Structured query plan generated by planner agents
 */
export const QueryPlanSchema = z.object({
  intent_summary: z.string().describe("Brief description of what the query is trying to accomplish"),
  entities: z.array(z.string()).describe("List of database entities/tables involved"),
  columns: z.array(z.string()).describe("Specific columns to select"),
  filters: z.array(z.object({
    column: z.string(),
    operator: z.enum(["=", "!=", ">", "<", ">=", "<=", "LIKE", "IN", "NOT IN"]),
    value: z.union([z.string(), z.number(), z.array(z.union([z.string(), z.number()]))]),
    description: z.string().nullable()
  })).describe("Filter conditions to apply"),
  joins: z.array(z.object({
    left_table: z.string(),
    right_table: z.string(),
    left_column: z.string(),
    right_column: z.string(),
    type: z.enum(["INNER", "LEFT", "RIGHT", "FULL"]).default("INNER")
  })).describe("Table joins required"),
  aggregations: z.array(z.object({
    function: z.enum(["COUNT", "MAX", "MIN", "AVG", "SUM"]),
    column: z.string(),
    alias: z.string()
  })).nullable().describe("Aggregation functions to apply"),
  group_by: z.array(z.string()).nullable().describe("Columns to group results by"),
  time_window: z.object({
    start_date: z.string().nullable(),
    end_date: z.string().nullable(),
    days_back: z.number().default(30)
  }).describe("Time range for the query"),
  project_scope: z.string().describe("Project ID to scope the query to"),
  is_cross_domain: z.boolean().default(false).describe("Whether this query spans multiple domains"),
  domains: z.array(z.string()).nullable().describe("List of domains involved in cross-domain queries"),
  explanation: z.string().describe("Reasoning for the query plan choices")
});

export type QueryPlan = z.infer<typeof QueryPlanSchema>;

/**
 * Result of SQL validation and generation
 */
export interface ValidationResult {
  isValid: boolean;
  issues: string[];
  safeSQL?: string;
}

/**
 * Result of database query execution
 */
export interface ExecutionResult {
  rows: any[];
  rowCount: number;
  executionTimeMs: number;
  queryHash: string;
}

/**
 * Input for the main workflow function
 */
export interface WorkflowInput {
  input_as_text: string;
  project_id: string;
}

/**
 * Guardrail result structure
 */
export interface GuardrailResult {
  tripwireTriggered: boolean;
  categories?: string[];
  safeText?: string;
}

/**
 * Final response from the agent
 */
export interface AgentResponse {
  success: boolean;
  answer?: string;
  error?: string;
  metadata?: {
    domain: Domain;
    queryHash: string;
    executionTimeMs: number;
    rowCount: number;
  };
}
